# Sorting_Algorihms

def belong (number, list_of_numbers):
  for element in list_of_numbers:
      if (element==number):
        print("true")
       else:
        print("flase")


def belong(n,t):
  i=Q
  while i<len(T):
    if n==T[i]:
      return True
     i=i+1
      return False
def my_sum(t):
  res=t[o]
  for i in range (1,len(t)):
  res=res+t[i]
  return res
  
  
def belong(x;t):
  tr=False
  i=0
  while (i<=len(t)) and tr==False):
    if (t=[i]==x):
      tr=True
    i=i+1
  return(tr)
  
def greastest_in (t):
  res=t[0]
  for element in t:
    if element>res:
      res=element
  return res
  
def my_len(t)
  cpt=0
  for element in t:
    cpt=cpt+1
  return cpt
  
def map_double (t):
  res=[0]xlen(t):
    for i in range(len(t)):
      res(i]=2xt[i]
      
def smallest in (t,i,j):
  for indice in range(i+1,j+1):
  if t[indice]
  return(res)
  
def remove(t,i):
  res=(o]x(len(t)-1)
  for j in range(len(t):
    if j<i:
      res[j]=t(j]
    if j>i:
      res[j)=t(j]
  return res
  
def my_selection_sort(t):
  res=[0]xlen(t)
  for i in range (len(t))
    j=t(index_of_the_smallest(t)]
    res[i]=t[j]
    remove(t,j)
  return res
  
def selection_sort_inplace (t):
  for index in range (len(t))
    s=index_of_the_smallest_in(t,index len(t)-1)
    if s>index:
      swap(t,index,s)
    return null
    
def insertion_sort_inplace(t):
  for inder in range (1,len(t)):
    insert(t,index)
  return null
  
def insert (t,index):
  for current_index in range(index-1,-1,-1)
    if t[current_index]>t[current_index-1]
      swap(t,current_index,current_index-1)
    else:break
    

  
  
